<html>
  <head>
    <meta charset="UTF-8" />
    <style>
      html, body { 
        background-color:#000;
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden !important;  
      }
    </style>
    <script src="https://threejs.org/build/three.min.js" type="text/javascript"></script>
    <script src="https://threejs.org/examples/js/controls/TrackballControls.js" type="text/javascript"></script>
    <script>

        var speed = 5;
        var delta = 1 / speed;
        var movement_speed = 0.0;

        var clock = new THREE.Clock();

        var keys = [];

        var snake = [];
        var apple;

        var pad = .15;
        var boardEdge = 20;
        var boardSize = boardEdge + (boardEdge - 1) * pad;
        var halfBoard = boardSize / 2;

        var direction = new THREE.Vector3(1, 0, 0);

        var end = false;


        window.onload = function() {

          scene = new THREE.Scene();

          fov = 75;
          ratio = window.innerWidth / window.innerHeight;
          zNear = 1;
          zFar = 10000;

          camera = new THREE.PerspectiveCamera(fov, ratio, zNear, zFar);
          camera.position.set( 30, 20, 30);

          renderer = new THREE.WebGLRenderer();
          renderer.setSize( window.innerWidth, window.innerHeight );
          document.body.appendChild( renderer.domElement );
          
          ambientLight = new THREE.AmbientLight();
          scene.add( ambientLight );

          light = new THREE.DirectionalLight( 0xffffff, 5.0 );
          light.position.set( 10, 100, 10 );
          scene.add( light );


          controls = new THREE.TrackballControls( camera, renderer.domElement );

          //
          // ACTION!
          //

          var floorTexture = new THREE.TextureLoader().load( 'rock.jpg' );
          var floorGeometry = new THREE.PlaneBufferGeometry( 24, 24 );
          var floorMaterial = new THREE.MeshBasicMaterial( {
              map: floorTexture,
              color: 0x808487,
              side: THREE.DoubleSide
          } );

          floor = new THREE.Mesh( floorGeometry, floorMaterial );
          floor.position.z = -12;
          scene.add( floor );

          var floorTexture = new THREE.TextureLoader().load( 'rock.jpg' );
          var floorGeometry = new THREE.PlaneBufferGeometry( 24, 24 );
          var floorMaterial = new THREE.MeshBasicMaterial( {
              map: floorTexture,
              color: 0x808487,
              side: THREE.DoubleSide
          } );

          floor = new THREE.Mesh( floorGeometry, floorMaterial );
          floor.position.y = -12;
          floor.rotateX(Math.PI/2);
          scene.add( floor );

          var floorTexture = new THREE.TextureLoader().load( 'rock.jpg' );
          var floorGeometry = new THREE.PlaneBufferGeometry( 24, 24 );
          var floorMaterial = new THREE.MeshBasicMaterial( {
              map: floorTexture,
              color: 0x808487,
              side: THREE.DoubleSide
          } );

          floor = new THREE.Mesh( floorGeometry, floorMaterial );
          floor.rotateY(Math.PI/2);
          floor.position.x = -12;
          scene.add( floor );

          for ( var i = 0; i < 5; i ++ ) {
              var snakeMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
              snake.push( new createCube( new THREE.Vector3((i + i * pad) - halfBoard + 0.5, 0.5 + pad / 2, 0.5 + pad / 2), snakeMaterial, scene ));
          }


          for ( var i = 0; i < 3; i++ ) {
            var appleMaterial = new THREE.MeshPhongMaterial( { color: 0xff0000 } );
            apple = new createCube( createApple(), appleMaterial, scene );
          }


          clock.startTime = 0.0;
          
          animate();
        };

        function restart() {

            while ( snake.length > 5) { scene.remove( snake.shift().mesh )};

            for ( var i = 0; i < snake.length; i++) {
                snake[i].setPosition((i + i * pad) - halfBoard + 0.5, 0.5 + pad / 2, 0.5 + pad / 2);
            }

            end = false;
            direction = new THREE.Vector3( 1, 0, 0 );

        };

        function createApple() {

            var x, y, z;
            x = y = z = (Math.random() * boardEdge - 1); 

            return new THREE.Vector3((x + x * pad) - halfBoard + 0.5, (y + y * pad) - halfBoard + 0.5, (z + z * pad) - halfBoard + 0.5);
        };

        function createCube( vec, material, scene, geometry ) {

            this.geometry = new THREE.BoxGeometry( 1, 1, 1 );
            this.mesh = new THREE.Mesh(this.geometry, material);

            this.mesh.position.set(vec.x, vec.y, vec.z);
            scene.add(this.mesh);

            this.setPosition = function(vec) {
                this.mesh.position.set( vec.x, vec.y, vec.z );
            };

        };


      function animate() {

        requestAnimationFrame( animate );

        movement_speed += clock.getDelta();

        if ( movement_speed > delta ) {

          var tail = snake.shift();
          var head = snake[snake.length - 1];

          direction = keys.length > 0 ? keys.pop(0) : direction;
          var movement = new THREE.Vector3(
                             /* X */    head.mesh.position.x + direction.x + Math.sign(direction.x) * pad, 
                             /* Y */    head.mesh.position.y + direction.y + Math.sign(direction.y) * pad,
                             /* Z */    head.mesh.position.z + direction.z + Math.sign(direction.z) * pad
        )
        tail.setPosition( movement );

        snake.push( tail );
        head = tail;

        for (var i = snake.length - 2; i > -1; i--) {
          if ( head.mesh.position.distanceTo(snake[i].mesh.position) < 1) {
            end = true;
            break;
          }
        };

        if ( end ) { restart(); };

        if ( head.mesh.position.distanceTo(apple.mesh.position) < 2) {

              apple.setPosition( createApple() );
              snake.unshift( new createCube( new THREE.Vector3(snake[0].mesh.position.x, snake[0].mesh.position.y, snake[0].mesh.position.z), new THREE.MeshToonMaterial( { color: 0x00ff00} ), scene));
        };

        if ( head.mesh.position.x < -halfBoard) {
          head.mesh.position.x = halfBoard - 0.5;
        } else if ( head.mesh.position.x > halfBoard) {
          head.mesh.position.x = -halfBoard + 0.5;
        } else if ( head.mesh.position.y < -halfBoard) {
          head.mesh.position.y = halfBoard - 0.5;
        } else if ( head.mesh.position.y > halfBoard) {
          head.mesh.position.y = -halfBoard + 0.5;
        } else if ( head.mesh.position.z < -halfBoard) {
          head.mesh.position.z = halfBoard - 0.5;
        } else if ( head.mesh.position.z > halfBoard) {
          head.mesh.position.z = -halfBoard + 0.5;
        }

        movement_speed = 0;

      
      };


        controls.update();
        renderer.render( scene, camera );

      };

      document.addEventListener("keydown", function(e){
            switch(e.key){
                case 'q':
                    keys.push(new THREE.Vector3(0,1,0));
                break;
                case 'a':
                    keys.push(new THREE.Vector3(0,-1,0));
                break;
                case "ArrowDown":
                    keys.push(new THREE.Vector3(0,0,1));
                break;
                case "ArrowUp":
                    keys.push(new THREE.Vector3(0,0,-1));
                break;
                case "ArrowLeft":
                    keys.push(new THREE.Vector3(-1,0,0));
                break;
                case "ArrowRight":
                    keys.push(new THREE.Vector3(1,0,0));
                break;
            }
        });

    </script>
  </head>
  <body></body>
</html>
